import{a1 as r,a8 as c,ae as A,a3 as o,a7 as I,a2 as K,a4 as E,af as Q,ag as h,a0 as N,a5 as B,ah as _,ai as k,$ as R,aj as j,P as O,g as P,X as U,Y as u,q as x}from"./DrJXerId.js";import{a as V,e as X}from"./CPAmBVur.js";const Y=A(["daily","monthly","weekly","yearly"]),v=r({id:o(),repetitionCount:o(),frequency:Y,endDate:c().datetime({offset:!0})}),z=v.pick({frequency:!0,repetitionCount:!0,endDate:!0}),y=r({id:o({required_error:"Identifiant requis",invalid_type_error:"L'identifiant doit être un nombre"}),amount:o({required_error:"Le montant est requis",invalid_type_error:"Le montant doit être un nombre"}).positive("Le montant doit être positif"),title:c({required_error:"Le titre est requis",invalid_type_error:"Le titre doit être une chaîne de caractères"}).min(3,"Le titre doit contenir au moins 3 caractères").max(255,"Le titre doit contenir au maximum 255 caractères"),groupe:B.shape.id,category:N,creator:h,spentAt:Q,recurring:v.nullable(),participants:E(h,{invalid_type_error:"Les participants doivent être une liste d'utilisateurs"}).optional()}),te=r({categoryId:o().optional(),title:y.shape.title,amount:y.shape.amount,spentAt:k(),authorId:_.shape.id,groupId:B.shape.id,recurring:z.nullable().optional(),participants:E(_.shape.id)}),H=y.pick({amount:!0,id:!0,title:!0,category:!0}).extend({creator:h.pick({picture:!0,username:!0})}),J=E(H,{invalid_type_error:"Les dépenses doivent être une liste"}),g=I(K,J),W=()=>{const{$api:s}=R();return{getExpenseById:e=>s.get({url:`expenses/${e}`,schema:y}),getAllExpensesByGroup:e=>s.get({url:`expenses/groupe/${e}/list`,schema:g}),getMonthlyExpensesByGroup:(e,n)=>s.get({url:`expenses/groupe/${e}/mois/${V(n)}/list`,schema:g}),getExpensesByCategory:e=>s.get({url:`expenses/category/${e}/list`,schema:g}),postExpense:e=>s.post({url:"expenses",body:e,schema:r({message:c()})}),patchExpense:(e,n)=>s.patch({url:`expenses/${e}`,body:n,schema:r({message:c()})}),deleteExpense:e=>s.delete({url:`expenses/${e}`,schema:j()})}},se=()=>{const s=O(),{group_id:t,category_id:p,expense_id:a}=s.params,i=P(),{postExpense:q,getExpenseById:S,patchExpense:b,deleteExpense:e,getAllExpensesByGroup:n,getExpensesByCategory:f,getMonthlyExpensesByGroup:M}=W(),d=U(),l=async()=>{await Promise.all([d.invalidateQueries({queryKey:["expenses-by-group",t]}),d.invalidateQueries({queryKey:["budget","remaining",Number(t)]})])},{data:C}=u({queryKey:["expense-by-id",a],queryFn:()=>S(a),enabled:!!a}),L=x({mutationFn:m=>q(m),onSuccess:async()=>{await l(),i.push({name:"group",params:{group_id:t}})}}),w=x({mutationFn:m=>b(a,m),onSuccess:async()=>{await d.invalidateQueries({queryKey:["expense-by-id",a]}),await l(),await i.push({name:"expense",params:{id:a,group_id:t}})}}),D=x({mutationFn:()=>e(a),onSuccess:async()=>{await l(),i.push({name:"group",params:{group_id:t}})}}),{data:F}=u({queryKey:["expenses-by-group",t],queryFn:()=>n(t),enabled:!!t}),{data:G}=u({queryKey:["expenses-by-category",p],queryFn:()=>f(p),enabled:p!==void 0}),{data:T,refetch:$}=u({queryKey:["expenses-monthly-group",t],queryFn:()=>M(t,X())});return{expenses:F,expense:C,createExpenseMutation:L,updateExpenseMutation:w,deleteExpenseMutation:D,expensesByCategory:G,expensesByMonthAndGroup:T,refetchByMonthAndGroup:$}};export{Y as F,te as N,se as u};
